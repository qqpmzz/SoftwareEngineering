# Chapter 1 - 소프트웨어 공학 정리

## 개요
이 문서는 "Software and Software Engineering Introduction" Chapter1.pdf의 내용을 페이지별로 정리한 노트입니다.

---

## 페이지별 정리

### Page 1 - 표지
**제목:** Software and Software Engineering Introduction

**주요 내용:**
- Chapter 1 소개 페이지
- McGraw Hill 출판사
- 2020년 저작권

**키워드:**
- Software Engineering
- Introduction
- McGraw Hill

---

### Page 2 - 소프트웨어의 정의
**제목:** Nature of Software – Defining Software

**주요 내용:**
- 소프트웨어는 다음 3가지 요소로 구성:
  1. **Instructions (프로그램)**: 실행될 때 원하는 기능과 성능을 제공하는 컴퓨터 프로그램
  2. **Data structures**: 프로그램이 정보를 적절히 조작할 수 있게 하는 데이터 구조
  3. **Documentation**: 프로그램의 운영과 사용을 설명하는 문서

**키워드:**
- Instructions
- Data structures
- Documentation

---

### Page 3 - 소프트웨어의 특징
**제목:** What is Software?

**주요 내용:**
- 소프트웨어는 개발되거나 공학적으로 설계되며, 전통적인 의미로 제조되는 것이 아님
- 소프트웨어는 "마모"되지 않지만 악화(deteriorate)됨
- 산업이 컴포넌트 기반 구축으로 이동하고 있지만, 대부분의 소프트웨어는 여전히 맞춤형으로 제작됨

**키워드:**
- Engineered
- Component-based
- Custom-built

---

### Page 4 - 소프트웨어 응용 도메인
**제목:** Software Application Domains

**주요 내용:**
- **System software**: 시스템 소프트웨어
- **Application software**: 응용 소프트웨어
- **Engineering/Scientific software**: 공학/과학 소프트웨어
- **Embedded software**: 임베디드 소프트웨어
- **Product-line software**: 제품군 소프트웨어
- **Web/Mobile applications**: 웹/모바일 애플리케이션
- **AI software**: AI 소프트웨어 (로보틱스, 신경망, 게임 등)

**키워드:**
- Application Domains
- System Software
- AI Software

---

### Page 5 - 소프트웨어 위기의 등장
**제목:** 소프트웨어 크라이시스(Crisis)

**주요 내용:**
- **소프트웨어 위기 배경**: 컴퓨터 계산 용량과 문제 복잡도 급증으로 새로운 개발 방법 필요성 인식
- **소프트웨어 위기의 주요 원인**:
  - 소프트웨어 규모 대형화 및 복잡도 증가로 인한 개발 비용 증대
  - 유지보수의 어려움과 개발 정체 현상
  - 프로젝트 기간 및 예산 예측의 어려움
  - 신기술 교육 및 훈련 부족
  - 사용자 기대치 증가
  - 요구사항의 빈번한 변경 및 반영 필요

**키워드:**
- Software Crisis
- 복잡도 증가
- 유지보수

---

### Page 6 - 소프트웨어 개발의 어려움
**제목:** 왜 소프트웨어 개발이 어려운가

**주요 내용:**
- **의사소통 문제**: 다양한 역할자(PM, QA, 개발자, 사용자) 간 소통 오류
- **시스템의 순차 특성**: 3차원 실세계를 2차원 평면의 코드로 변환
- **개발 결과물**: 조립이나 공식이 아닌 개발자의 지적 활동 산출물
- **프로젝트 복잡성**: 프로젝트마다 다른 기간, 개발자 수, 사용자 수준
- **다양한 관리 이슈**: 요구사항 변경, 일정 관리, 버전 관리 등의 오케스트레이션

**키워드:**
- 의사소통
- 복잡성
- 관리 이슈

---

### Page 7-8 - 소프트웨어 고장 패턴
**제목:** 소프트웨어 고장 그래프

**주요 내용:**
- 하드웨어 고장 그래프와 소프트웨어 고장 그래프의 차이점
- 소프트웨어는 시간이 지나면서 다른 고장 패턴을 보임
- 그래프를 통한 시각적 비교

**키워드:**
- 고장 패턴
- 하드웨어 vs 소프트웨어
- 시간 경과

---

---

### Page 9 - Legacy Software
**제목:** 왜 소프트웨어는 변경되어야 하는가?

**주요 내용:**
- 새로운 컴퓨팅 환경이나 기술에 적응하기 위해
- 새로운 비즈니스 요구사항 구현을 위해
- 다른 현대적 시스템이나 데이터베이스와 상호 운용 가능하게 하기 위해
- 네트워크 환경에서 사용 가능하도록 재설계하기 위해

**키워드:**
- Legacy Software
- 적응(Adaptation)
- 상호운용성(Interoperability)

---

### Page 10 - 소프트웨어 공학 정의 (IEEE)
**제목:** Defining the Discipline

**주요 내용:**
- **IEEE 정의에 따른 소프트웨어 공학**:
  1. 소프트웨어의 개발, 운영, 유지보수에 체계적이고 규율적이며 수치화 가능한 접근법의 적용
  2. 소프트웨어에 공학의 적용
  3. 이러한 접근법에 대한 연구

**키워드:**
- IEEE 정의
- Systematic
- Disciplined
- Quantifiable

---

### Page 11-12 - 소프트웨어 공학 정의 (한국어)
**제목:** 소프트웨어 공학의 정의

**주요 내용:**
- 소프트웨어 공학의 한국어 정의 제시
- 공학적 원리와 방법론의 소프트웨어 개발에의 적용

**키워드:**
- 소프트웨어 공학
- 공학적 원리
- 방법론

---

### Page 13 - 소프트웨어 공학의 목표
**제목:** 소프트웨어 공학의 목표

**주요 내용:**
- **개발 대상의 명확화**: 사용자 요구사항을 충족시키는 품질 좋은 소프트웨어 개발
- **개발 과정의 체계화**: 소프트웨어 개발을 위한 다양한 공학적 기법
- **개발 수명주기 지원**: 수명주기 전반에 걸친 지원

**키워드:**
- 품질 보증
- 체계적 개발
- 수명주기

---

### Page 14-16 - 소프트웨어 공학의 원리
**제목:** 소프트웨어 공학의 원리

**주요 내용:**
1. **엄격성과 정형성**: 소프트웨어는 개발자의 경험과 지식에 의존적이지만 단명하게 개발되어야 함
2. **관심사의 분할**: 복잡한 문제를 단순한 문제로 분리
3. **모듈화**: 독립적 기능, 높은 응집력과 낮은 결합력
4. **추상화**: 세부사항을 감추고 대표적 속성으로 정의
5. **변경의 예측**: 변경 발생을 대비한 공학적 방법
6. **일반화**: 다양한 플랫폼과 환경 지원
7. **점진성**: 단계적, 순차적 개발
8. **명세화**: 개발 과정과 대상물에 대한 체계적 기술

**키워드:**
- 모듈화
- 추상화
- 점진성

## 전체 요약

### 주요 개념
1. **소프트웨어의 정의**: 명령어, 데이터 구조, 문서로 구성된 지적 산출물
2. **소프트웨어 위기**: 복잡도 증가, 유지보수 어려움, 의사소통 문제 등
3. **소프트웨어 공학**: 체계적이고 규율적인 소프트웨어 개발 접근법

### 중요한 정의
- **소프트웨어**: 실행 시 원하는 기능을 제공하는 명령어 + 데이터 구조 + 문서
- **소프트웨어 공학**: 공학적 원리와 방법을 소프트웨어 개발에 체계적으로 적용
- **Legacy Software**: 변화하는 환경과 요구사항에 지속적으로 적응해야 하는 기존 소프트웨어

### 학습 목표
- 소프트웨어의 다양한 응용 도메인을 이해하고 분류할 수 있다
- 소프트웨어 위기의 원인을 분석하고 소프트웨어 공학의 필요성을 설명할 수 있다
- 소프트웨어 공학의 기본 원리를 이해하고 실제 프로젝트에 적용할 수 있다

---

### Page 17-26 - 소프트웨어 공학 실무
**제목:** Software Engineering Practice & Process Framework

**주요 내용:**

#### Page 17: Software Engineering Layers
- 소프트웨어 공학의 계층 구조

#### Page 18: Process Framework Activities
- **Communication**: 의사소통
- **Planning**: 계획
- **Modeling**: 모델링 (요구사항 분석 및 설계)
- **Construction**: 구축 (코드 생성 및 테스트)
- **Deployment**: 배포

#### Page 19: Umbrella Activities
- 소프트웨어 프로젝트 추적 및 제어
- 위험 관리
- 소프트웨어 품질 보증
- 기술 리뷰
- 측정
- 소프트웨어 구성 관리
- 재사용성 관리

#### Page 20-24: 소프트웨어 공학 실무의 본질
**Polya의 4단계 접근법:**
1. **문제 이해** (Communication and Analysis)
   - 이해관계자 파악
   - 미지수 식별
   - 문제 세분화
   - 그래픽 표현

2. **해결책 계획** (Modeling and Software Design)
   - 유사 문제 경험 활용
   - 기존 소루션 재사용
   - 서브 문제 정의
   - 설계 모델 생성

3. **계획 수행** (Code Generation)
   - 설계 모델과의 추적성
   - 소스 코드 검증

4. **결과 검사** (Testing & Quality Assurance)
   - 컴포넌트별 테스트
   - 이해관계자 요구사항 검증

#### Page 25: David Hooker의 일반 원칙
1. **존재 이유**: 사용자에게 가치 제공
2. **KISS 원칙**: 가능한 단순하게 설계
3. **비전 유지**: 명확한 비전 필수
4. **타인을 고려**: 다른 사람이 사용할 것을 고려
5. **미래에 열려 있기**: 자신을 직각에 몰아넣지 말 것
6. **재사용 계획**: 비용 절감과 가치 증대
7. **사고하기**: 행동 전에 사고하기

#### Page 26: 소프트웨어 프로젝트의 시작
**비즈니스 니즈에 의한 프로젝트 발생:**
- 기존 애플리케이션의 결함 수정
- 변화하는 비즈니스 환경에 따른 레거시 시스템 적응
- 기존 애플리케이션의 기능 및 특징 확장
- 새로운 제품, 서비스, 시스템 생성

**키워드:**
- Process Framework
- Polya의 4단계
- KISS 원칙
- 비즈니스 니즈

---

## 추가 정보

### 중요한 그래프/도표
- **Page 7-8**: 하드웨어 vs 소프트웨어 고장 패턴 비교 그래프
- **Page 17**: 소프트웨어 공학 계층 다이어그램

### 공학적 접근법의 핵심
1. **체계적 접근**: 무작정이 아닌 계획적 개발
2. **반복적 개선**: 지속적인 품질 향상
3. **표준화**: 일관된 방법론 적용
4. **측정 기반**: 정량적 지표로 관리

---

## 참고사항
- 원본 파일: Chapter1.pdf (McGraw Hill, 2020)
- 작성일: 2025년 10월 1일
- 추출 방법: pdfplumber 라이브러리 사용 OCR
- 총 페이지 수: 26페이지

## 완료 체크리스트
- [x] PDF 내용 실제 추출 및 확인
- [x] 각 페이지별 내용 체계적 정리
- [x] 주요 개념 및 정의 요약
- [x] 키워드 추출 및 정리
- [x] 학습 목표 설정
- [ ] 연습문제 추가 (필요 시)
- [ ] 다른 챕터와의 연관성 분석 (추후 수행)